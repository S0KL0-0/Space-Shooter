<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Research Tree System</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0f;
            font-family: Arial, sans-serif;
            color: white;
        }

        #tree-container {
            width: 100%;
            height: 80vh;
            border: 2px solid #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        #research-tree {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #research-tree:active {
            cursor: grabbing;
        }

        .research-node {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .research-node:hover .node-circle {
            stroke-width: 3;
            filter: brightness(1.3);
        }

        .node-circle {
            stroke-width: 2;
            transition: all 0.2s ease;
        }

        .node-circle.available {
            fill: #00ff41;
            stroke: #00cc33;
        }

        .node-circle.locked {
            fill: #333333;
            stroke: #555555;
        }

        .node-circle.researched {
            fill: #0099ff;
            stroke: #0077cc;
        }

        .node-circle.auto-unlocked {
            fill: #ffaa00;
            stroke: #ff8800;
        }

        .node-text {
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 10px;
            pointer-events: none;
            font-weight: bold;
        }

        .connection-line {
            stroke: #444444;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .connection-line.active {
            stroke: #00ff41;
            stroke-width: 3;
        }

        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            min-width: 220px;
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #00ff41;
        }

        .info-description {
            font-size: 14px;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .info-cost {
            font-size: 12px;
            color: #ffaa00;
        }

        .research-button {
            background: #00ff41;
            color: black;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
            font-size: 12px;
            font-weight: bold;
        }

        .research-button:hover {
            background: #00cc33;
        }

        .research-button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        .tier-label {
            fill: #888;
            font-size: 14px;
            font-weight: bold;
            text-anchor: start;
        }

        .demo-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .demo-controls button {
            margin: 5px;
            padding: 8px 16px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }

        .demo-controls button:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <h1>Modular Research Tree System</h1>
    <div id="tree-container">
        <svg id="research-tree" viewBox="0 0 1000 800">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#444444" />
                </marker>
                <marker id="arrowhead-active" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#00ff41" />
                </marker>
            </defs>
            
            <g id="tier-labels"></g>
            <g id="connections"></g>
            <g id="nodes"></g>
        </svg>
        
        <div id="info-panel">
            <div class="info-title">Select a Research Node</div>
            <div class="info-description">Click on any research node to view details</div>
        </div>
    </div>

    <div class="demo-controls">
        <h3>Demo Controls</h3>
        <button onclick="createWeaponsTree()">Create Weapons Tree</button>
        <button onclick="createTechTree()">Create Technology Tree</button>
        <button onclick="addRandomNode()">Add Random Node</button>
        <button onclick="resetTree()">Reset Tree</button>
    </div>

    <script>
        class ResearchTree {
            constructor(containerId, svgId) {
                this.containerId = containerId;
                this.svgId = svgId;
                this.nodes = {};
                this.playerResources = 1000;
                this.selectedNode = null;
                this.currentTransform = { x: 0, y: 0, scale: 1 };
                
                this.initializePanZoom();
            }

            // Add a new node to the tree
            addNode(id, name, description, cost, position, prerequisites = [], tier = 1, customData = {}) {
                const node = {
                    id,
                    name,
                    description,
                    cost,
                    position,
                    prerequisites,
                    tier,
                    customData,
                    status: cost === 0 ? 'researched' : 'locked'
                };

                this.nodes[id] = node;
                this.updateNodeStatuses();
                return node;
            }

            // Remove a node from the tree
            removeNode(id) {
                if (this.nodes[id]) {
                    // Remove dependencies
                    Object.values(this.nodes).forEach(node => {
                        node.prerequisites = node.prerequisites.filter(prereq => prereq !== id);
                    });
                    delete this.nodes[id];
                    this.updateNodeStatuses();
                }
            }

            // Get a node by ID
            getNode(id) {
                return this.nodes[id];
            }

            // Update node statuses based on prerequisites
            updateNodeStatuses() {
                // First pass: handle auto-unlocked nodes (cost = 0)
                Object.values(this.nodes).forEach(node => {
                    if (node.cost === 0 && node.status !== 'researched') {
                        node.status = 'researched';
                    }
                });

                // Second pass: unlock available nodes
                Object.values(this.nodes).forEach(node => {
                    if (node.status === 'locked' && node.cost > 0) {
                        const prereqsMet = node.prerequisites.every(prereqId => 
                            this.nodes[prereqId] && this.nodes[prereqId].status === 'researched'
                        );
                        
                        if (prereqsMet) {
                            node.status = 'available';
                        }
                    }
                });
            }

            // Check if a node can be researched
            canResearchNode(nodeId) {
                const node = this.nodes[nodeId];
                if (!node || node.status !== 'available') return false;
                if (this.playerResources < node.cost) return false;
                
                return node.prerequisites.every(prereqId => 
                    this.nodes[prereqId] && this.nodes[prereqId].status === 'researched'
                );
            }

            // Research a node
            researchNode(nodeId) {
                const node = this.nodes[nodeId];
                
                if (!this.canResearchNode(nodeId)) return false;
                
                this.playerResources -= node.cost;
                node.status = 'researched';
                
                this.updateNodeStatuses();
                this.render();
                return true;
            }

            // Select a node
            selectNode(nodeId) {
                this.selectedNode = this.nodes[nodeId];
                this.updateInfoPanel();
            }

            // Set player resources
            setResources(amount) {
                this.playerResources = amount;
                this.updateInfoPanel();
            }

            // Add resources
            addResources(amount) {
                this.playerResources += amount;
                this.updateInfoPanel();
            }

            // Render the entire tree
            render() {
                this.drawTierLabels();
                this.drawConnections();
                this.drawNodes();
                this.updateInfoPanel();
            }

            // Draw tier labels
            drawTierLabels() {
                const labelsGroup = document.getElementById('tier-labels');
                labelsGroup.innerHTML = '';

                const tiers = {};
                Object.values(this.nodes).forEach(node => {
                    if (!tiers[node.tier]) {
                        tiers[node.tier] = [];
                    }
                    tiers[node.tier].push(node);
                });

                Object.keys(tiers).sort((a, b) => a - b).forEach(tier => {
                    const minY = Math.min(...tiers[tier].map(node => node.position.y));
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 20);
                    text.setAttribute('y', minY - 30);
                    text.classList.add('tier-label');
                    text.textContent = `TIER ${tier}`;
                    labelsGroup.appendChild(text);
                });
            }

            // Draw connection lines
            drawConnections() {
                const connectionsGroup = document.getElementById('connections');
                connectionsGroup.innerHTML = '';

                Object.values(this.nodes).forEach(node => {
                    node.prerequisites.forEach(prereqId => {
                        const prereq = this.nodes[prereqId];
                        if (prereq) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', prereq.position.x);
                            line.setAttribute('y1', prereq.position.y + 30);
                            line.setAttribute('x2', node.position.x);
                            line.setAttribute('y2', node.position.y - 30);
                            line.classList.add('connection-line');
                            
                            if (prereq.status === 'researched') {
                                line.classList.add('active');
                                line.setAttribute('marker-end', 'url(#arrowhead-active)');
                            } else {
                                line.setAttribute('marker-end', 'url(#arrowhead)');
                            }
                            
                            connectionsGroup.appendChild(line);
                        }
                    });
                });
            }

            // Draw nodes
            drawNodes() {
                const nodesGroup = document.getElementById('nodes');
                nodesGroup.innerHTML = '';

                Object.values(this.nodes).forEach(node => {
                    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    nodeGroup.classList.add('research-node');
                    nodeGroup.setAttribute('data-id', node.id);

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.position.x);
                    circle.setAttribute('cy', node.position.y);
                    circle.setAttribute('r', 30);
                    
                    // Special styling for auto-unlocked nodes
                    if (node.cost === 0) {
                        circle.classList.add('node-circle', 'auto-unlocked');
                    } else {
                        circle.classList.add('node-circle', node.status);
                    }

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.position.x);
                    text.setAttribute('y', node.position.y);
                    text.classList.add('node-text');
                    text.textContent = node.name.split(' ')[0];

                    nodeGroup.appendChild(circle);
                    nodeGroup.appendChild(text);
                    nodesGroup.appendChild(nodeGroup);

                    nodeGroup.addEventListener('click', () => this.selectNode(node.id));
                });
            }

            // Update info panel
            updateInfoPanel() {
                const panel = document.getElementById('info-panel');
                
                if (!this.selectedNode) {
                    panel.innerHTML = `
                        <div class="info-title">Select a Research Node</div>
                        <div class="info-description">Click on any research node to view details</div>
                        <div class="info-cost">Resources: ${this.playerResources}</div>
                    `;
                    return;
                }

                const canResearch = this.canResearchNode(this.selectedNode.id);
                let buttonText = 'Locked';
                
                if (this.selectedNode.status === 'researched') {
                    buttonText = this.selectedNode.cost === 0 ? 'Auto-Unlocked' : 'Completed';
                } else if (this.selectedNode.status === 'available' && canResearch) {
                    buttonText = 'Research';
                }

                const costText = this.selectedNode.cost === 0 ? 'FREE' : this.selectedNode.cost;

                panel.innerHTML = `
                    <div class="info-title">${this.selectedNode.name}</div>
                    <div class="info-description">${this.selectedNode.description}</div>
                    <div class="info-cost">Cost: ${costText} | Resources: ${this.playerResources}</div>
                    <button class="research-button" onclick="currentTree.researchNode('${this.selectedNode.id}')" 
                            ${!canResearch || this.selectedNode.status !== 'available' ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                `;
            }

            // Initialize pan and zoom
            initializePanZoom() {
                let isPanning = false;
                let startPoint = { x: 0, y: 0 };

                const svg = document.getElementById(this.svgId);
                const nodesGroup = document.getElementById('nodes');
                const connectionsGroup = document.getElementById('connections');
                const labelsGroup = document.getElementById('tier-labels');

                svg.addEventListener('mousedown', (e) => {
                    if (e.target === svg) {
                        isPanning = true;
                        startPoint = { x: e.clientX, y: e.clientY };
                    }
                });

                svg.addEventListener('mousemove', (e) => {
                    if (isPanning) {
                        const dx = e.clientX - startPoint.x;
                        const dy = e.clientY - startPoint.y;
                        
                        this.currentTransform.x += dx;
                        this.currentTransform.y += dy;
                        
                        const transform = `translate(${this.currentTransform.x}, ${this.currentTransform.y}) scale(${this.currentTransform.scale})`;
                        nodesGroup.setAttribute('transform', transform);
                        connectionsGroup.setAttribute('transform', transform);
                        labelsGroup.setAttribute('transform', transform);
                        
                        startPoint = { x: e.clientX, y: e.clientY };
                    }
                });

                svg.addEventListener('mouseup', () => {
                    isPanning = false;
                });

                svg.addEventListener('mouseleave', () => {
                    isPanning = false;
                });

                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.currentTransform.scale *= delta;
                    this.currentTransform.scale = Math.max(0.5, Math.min(2, this.currentTransform.scale));
                    
                    const transform = `translate(${this.currentTransform.x}, ${this.currentTransform.y}) scale(${this.currentTransform.scale})`;
                    nodesGroup.setAttribute('transform', transform);
                    connectionsGroup.setAttribute('transform', transform);
                    labelsGroup.setAttribute('transform', transform);
                });
            }
        }

        // Global tree instance
        let currentTree = new ResearchTree('tree-container', 'research-tree');

        // Demo functions
        function createWeaponsTree() {
            currentTree = new ResearchTree('tree-container', 'research-tree');
            currentTree.setResources(2000);

            // Tier 1 - Starting node (free)
            currentTree.addNode('basic-weapons', 'Basic Weapons', 'Starting weapon systems', 0, { x: 200, y: 100 }, [], 1);

            // Tier 2
            currentTree.addNode('lasers', 'Laser Weapons', 'Energy-based weapons', 150, { x: 150, y: 250 }, ['basic-weapons'], 2);
            currentTree.addNode('kinetic', 'Kinetic Weapons', 'Projectile weapons', 120, { x: 250, y: 250 }, ['basic-weapons'], 2);

            // Tier 3
            currentTree.addNode('plasma', 'Plasma Cannons', 'Advanced energy weapons', 300, { x: 100, y: 400 }, ['lasers'], 3);
            currentTree.addNode('railgun', 'Railguns', 'Electromagnetic projectiles', 350, { x: 200, y: 400 }, ['kinetic'], 3);
            currentTree.addNode('missiles', 'Smart Missiles', 'Guided explosive weapons', 250, { x: 300, y: 400 }, ['kinetic'], 3);

            currentTree.render();
        }

        function createTechTree() {
            currentTree = new ResearchTree('tree-container', 'research-tree');
            currentTree.setResources(1500);

            // Starting tech (free)
            currentTree.addNode('basic-tech', 'Basic Technology', 'Foundation research', 0, { x: 300, y: 100 }, [], 1);

            // Tier 2
            currentTree.addNode('computers', 'Computer Systems', 'Digital processing', 200, { x: 200, y: 250 }, ['basic-tech'], 2);
            currentTree.addNode('materials', 'Advanced Materials', 'New composite materials', 180, { x: 400, y: 250 }, ['basic-tech'], 2);

            // Tier 3
            currentTree.addNode('ai', 'Artificial Intelligence', 'Machine learning systems', 500, { x: 150, y: 400 }, ['computers'], 3);
            currentTree.addNode('quantum', 'Quantum Computing', 'Quantum processors', 600, { x: 250, y: 400 }, ['computers'], 3);
            currentTree.addNode('nanotech', 'Nanotechnology', 'Molecular engineering', 400, { x: 350, y: 400 }, ['materials'], 3);
            currentTree.addNode('fusion', 'Fusion Power', 'Clean energy source', 450, { x: 450, y: 400 }, ['materials'], 3);

// Tier 4
currentTree.addNode('smth', 'SMTH', 'smth of SMTH', 333, { x: 150, y: 550 }, ['ai'], 4);

            currentTree.render();
        }

        function addRandomNode() {
            const names = ['Scanner', 'Shield', 'Engine', 'Reactor', 'Armor', 'Sensor', 'Comm'];
            const descriptions = ['Advanced system', 'Improved technology', 'Enhanced capability', 'Next-gen solution'];
            
            const id = `node_${Date.now()}`;
            const name = names[Math.floor(Math.random() * names.length)] + ' ' + Math.floor(Math.random() * 100);
            const desc = descriptions[Math.floor(Math.random() * descriptions.length)];
            const cost = Math.floor(Math.random() * 500) + 50;
            const x = Math.floor(Math.random() * 800) + 100;
            const y = Math.floor(Math.random() * 600) + 100;
            
            const existingNodes = Object.keys(currentTree.nodes);
            const prereqs = existingNodes.length > 0 ? [existingNodes[Math.floor(Math.random() * existingNodes.length)]] : [];
            
            currentTree.addNode(id, name, desc, cost, { x, y }, prereqs, Math.floor(Math.random() * 3) + 1);
            currentTree.render();
        }

        function resetTree() {
            currentTree = new ResearchTree('tree-container', 'research-tree');
            currentTree.render();
        }

        // Initialize with weapons tree
        window.addEventListener('load', createWeaponsTree);
    </script>
</body>
</html>